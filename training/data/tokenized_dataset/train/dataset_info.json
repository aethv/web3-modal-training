{
    "examples": [
      {
        "prompt": "Create a simple ERC-20 token with the name 'MyToken', symbol 'MTK', and a total supply of 1 million tokens",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MyToken is ERC20 {\n    constructor() ERC20(\"MyToken\", \"MTK\") {\n        _mint(msg.sender, 1000000 * 10 ** decimals());\n    }\n}"
      },
      {
        "prompt": "Create a basic NFT collection with 10,000 max supply",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyNFT is ERC721Enumerable, Ownable {\n    uint256 public constant MAX_SUPPLY = 10000;\n    uint256 public constant PRICE = 0.05 ether;\n    string private baseURI;\n    \n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n    \n    function mint(uint256 quantity) external payable {\n        require(totalSupply() + quantity <= MAX_SUPPLY, \"Exceeds maximum supply\");\n        require(msg.value >= PRICE * quantity, \"Insufficient payment\");\n        \n        for (uint256 i = 0; i < quantity; i++) {\n            _safeMint(msg.sender, totalSupply() + 1);\n        }\n    }\n    \n    function setBaseURI(string memory _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n    \n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n    \n    function withdraw() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n}"
      },
      {
        "prompt": "Create a basic DeFi staking contract where users can stake tokens and earn rewards",
        "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract StakingRewards is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public stakingToken;\n    IERC20 public rewardsToken;\n    \n    uint256 public rewardRate = 100; // Tokens per second\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n    uint256 private _totalSupply;\n    \n    constructor(address _stakingToken, address _rewardsToken) {\n        stakingToken = IERC20(_stakingToken);\n        rewardsToken = IERC20(_rewardsToken);\n    }\n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return rewardPerTokenStored + (\n            ((block.timestamp - lastUpdateTime) * rewardRate * 1e18) / _totalSupply\n        );\n    }\n    \n    function earned(address account) public view returns (uint256) {\n        return (\n            (_balances[account] * (rewardPerToken() - userRewardPerTokenPaid[account])) / 1e18\n        ) + rewards[account];\n    }\n    \n    function updateReward(address account) internal {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = block.timestamp;\n        \n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n    }\n    \n    function stake(uint256 amount) external nonReentrant updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        _totalSupply += amount;\n        _balances[msg.sender] += amount;\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    function withdraw(uint256 amount) external nonReentrant updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply -= amount;\n        _balances[msg.sender] -= amount;\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    function getReward() external nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n    \n    function setRewardRate(uint256 _rewardRate) external onlyOwner updateReward(address(0)) {\n        rewardRate = _rewardRate;\n        emit RewardRateUpdated(_rewardRate);\n    }\n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = block.timestamp;\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n    \n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardRateUpdated(uint256 newRate);\n}"
      }
    ]
  }